# CS-320-JUnit-Contact-Service-Files-
How can I ensure that my code, program, or software is functional and secure?

I ensure my software is functional by building to clear requirements and validating behavior with repeatable testing. I use unit tests (JUnit) to confirm each requirement works as expected, including both positive cases (valid input) and negative cases (invalid input, duplicates, missing IDs). I also rely on code reviews of my own work—re-reading logic, checking edge cases, and keeping methods small and focused—so bugs are easier to detect. For security, I focus on input validation, enforcing constraints (like length limits and required fields), and failing safely by throwing exceptions when data is invalid instead of allowing the program to continue in a broken state. I also limit what can be modified (for example, preventing an ID from being changed after creation) and avoid exposing internal data structures directly. When applicable, I follow least-privilege thinking (only allow what is needed), keep dependencies updated, and document expected behavior so security and correctness aren’t “guessed” later.

How do I interpret user needs and incorporate them into a program?

I start by translating user needs into specific, testable requirements. If a user story says “a user must be able to create, update, and delete records,” I break that into behaviors like add/update/delete operations, validation rules, and error handling for invalid actions. I also prioritize what matters most to the user (accuracy, speed, simplicity, clarity) and design the program around those priorities. For example, when user data has strict formatting requirements, I enforce those constraints in constructors and setters, then write tests to prove those rules are consistently applied. If the user needs reliability, I add defensive checks and meaningful error messages. If the user needs ease of use, I simplify workflows and keep outputs clear and predictable. I treat feedback and test results as “user signals” too—if a feature is confusing or breaks easily, that indicates a need for better design or clearer requirements.

How do I approach designing software?

I approach design by starting with structure before details. First, I identify the main responsibilities of the system (models, services, storage, UI) and keep each part focused on a single purpose. Then I create a simple design that meets requirements without extra complexity, using modular classes and clear method boundaries so the code is easier to test and maintain. I typically design iteratively: build a working baseline, write tests, refactor for clarity, and repeat. I use patterns like separation of concerns (business logic in services, validation in data objects) and I keep interfaces clean so changes don’t ripple through the entire codebase. I also design with testing in mind—if a component is hard to test, it usually means it’s doing too much, so I break it into smaller pieces. Overall, my goal is readable, maintainable code that matches requirements and can be confidently verified through automated tests.
